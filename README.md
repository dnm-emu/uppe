# Отчёт по анализу производительности Java-приложения
Цель работы

Целью данной работы является изучение способов анализа производительности Java-приложений, а также практическое применение инструментов мониторинга, профилирования и диагностики проблем, связанных с многопоточностью, памятью и сборкой мусора. В рамках работы проводился анализ работы парсера и поиск возможных причин деградации производительности.

Используемые инструменты

В процессе выполнения задания были использованы следующие инструменты:

Micrometer и Prometheus — для сбора и экспорта метрик приложения;

VisualVM и Java Flight Recorder (JFR) — для профилирования JVM и анализа потоков и памяти;

JMH (Java Microbenchmark Harness) — для бенчмаркинга различных реализаций обработки данных;

OpenTelemetry и Jaeger — для распределённого трейсинга и анализа времени выполнения этапов парсинга.

Сбор метрик с помощью Micrometer и Prometheus

В приложение были добавлены метрики производительности с использованием библиотеки Micrometer.
Измерялись следующие показатели:

время выполнения операции парсинга;

количество успешных операций;

количество операций, завершившихся с ошибкой.

Метрики экспортируются через endpoint /actuator/prometheus и могут быть использованы для последующего мониторинга в Prometheus или Grafana.

Профилирование и диагностика с помощью VisualVM и JFR

Для анализа работы приложения использовался инструмент VisualVM. В процессе профилирования были выполнены:

получение thread dump для анализа состояния потоков;

получение heap dump для оценки использования памяти.

В ходе анализа было замечено, что при активной работе приложения сборщик мусора выполняет преимущественно minor GC, что характерно для приложений с частым созданием временных объектов. Основную часть используемой памяти занимают строки и коллекции.

Анализ управления памятью и GC

При выполнении парсинга создаётся значительное количество временных объектов, что приводит к увеличению нагрузки на сборщик мусора. Частота вызовов GC увеличивается при росте количества обрабатываемых данных. Анализ heap dump показал, что наибольший объём памяти занимают объекты типа String и коллекции, используемые для хранения результатов парсинга.

Бенчмаркинг с использованием JMH

Для сравнения производительности различных способов обработки данных был использован JMH.
Были протестированы следующие варианты реализации:

использование классического цикла for;

использование parallelStream.

Результаты бенчмаркинга показали, что при достаточной нагрузке и объёме данных использование parallelStream может обеспечивать более высокую производительность за счёт параллельного выполнения, однако при малом объёме данных накладные расходы могут нивелировать преимущество параллельной обработки.

Поиск и исправление деградации производительности

В ходе анализа были выявлены следующие потенциальные проблемы:

частые аллокации временных объектов;

избыточная обработка данных в потоках.

После упрощения логики обработки и сокращения количества создаваемых объектов удалось повысить стабильность выполнения и снизить нагрузку на сборщик мусора. В результате время выполнения операций стало более предсказуемым.

Настройка OpenTelemetry и Jaeger

Для анализа времени выполнения этапов парсинга был использован OpenTelemetry.
Вокруг ключевого этапа обработки данных был добавлен span, который позволяет отслеживать длительность выполнения операции. Собранные трейсы могут быть просмотрены в системе Jaeger в виде диаграмм выполнения.
